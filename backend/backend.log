INFO:     Will watch for changes in these directories: ['/Users/alexbelski/Desktop/new bi project/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [46488] using WatchFiles
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [46492]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     127.0.0.1:60941 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:60945 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:60984 - "POST /api/emails/settings/settings HTTP/1.1" 422 Unprocessable Content
INFO:     127.0.0.1:61025 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:61026 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:61029 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:61041 - "OPTIONS /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61043 - "OPTIONS /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61041 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61043 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61047 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:61048 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:61049 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:61043 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61041 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61074 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:61078 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:61107 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:61111 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:61194 - "POST /api/emails/settings/settings HTTP/1.1" 500 Internal Server Error
INFO:     127.0.0.1:61227 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:61228 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:61229 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:61232 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61234 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61238 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:61239 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:61240 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:61234 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61232 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:61271 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:61272 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61273 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61275 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61279 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:61282 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61285 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61289 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61484 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:61485 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61486 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61487 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61492 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:61495 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61498 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61501 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
WARNING:  WatchFiles detected changes in 'app/routers/email_settings.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [46492]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [47814]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Will watch for changes in these directories: ['/Users/alexbelski/Desktop/new bi project/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [47871] using WatchFiles
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [47875]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     127.0.0.1:62982 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:62983 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:62984 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:62986 - "OPTIONS /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:62988 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:62986 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:62995 - "OPTIONS /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:62998 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:62995 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:62986 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:62999 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:62986 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:63021 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:63024 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:63129 - "POST /api/emails/settings/settings HTTP/1.1" 500 Internal Server Error
INFO:     127.0.0.1:63194 - "POST /api/emails/settings/settings HTTP/1.1" 500 Internal Server Error
INFO:     127.0.0.1:63254 - "POST /api/emails/settings/settings HTTP/1.1" 500 Internal Server Error
INFO:     127.0.0.1:63332 - "POST /api/emails/settings/settings HTTP/1.1" 500 Internal Server Error
INFO:     127.0.0.1:63510 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:63572 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:63695 - "POST /api/emails/settings/test-connection HTTP/1.1" 200 OK
INFO:     127.0.0.1:63756 - "POST /api/emails/settings/settings HTTP/1.1" 500 Internal Server Error
INFO:     Will watch for changes in these directories: ['/Users/alexbelski/Desktop/new bi project/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [49847] using WatchFiles
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [49851]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     127.0.0.1:64511 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:64515 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:64596 - "POST /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:64659 - "POST /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:64739 - "POST /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:64813 - "POST /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:64927 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:64931 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:64932 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:64939 - "OPTIONS /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:64939 - "OPTIONS /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:64942 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:64939 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:64944 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:64948 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:64949 - "GET /api/emails/inbox?filter_status=new&limit=50&offset=0 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64939 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:64950 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:64953 - "GET /api/emails/inbox?filter_status=new&limit=50&offset=0 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64939 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:65003 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:65007 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:65031 - "POST /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:65066 - "POST /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:65085 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:65087 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:65089 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:65094 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:65095 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:65100 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:65103 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:65095 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:65104 - "GET /api/emails/inbox?filter_status=new&limit=50&offset=0 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65105 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:65095 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:65108 - "GET /api/emails/inbox?filter_status=new&limit=50&offset=0 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65322 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:65323 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65324 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65325 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:65330 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:65333 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65336 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65339 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:65434 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65435 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:65436 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:65437 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65441 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65443 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:65446 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:65449 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65474 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:65475 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65476 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65477 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:65481 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:65483 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65486 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65489 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:65527 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:65531 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:49185 - "POST /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:49223 - "POST /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:49420 - "POST /api/emails/settings/settings HTTP/1.1" 422 Unprocessable Content
INFO:     127.0.0.1:49474 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:49475 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49477 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49478 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:49482 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:49485 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49488 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49491 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:49765 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:49766 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49767 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49768 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:49772 - "GET /api/analytics/sales-trend?period=month HTTP/1.1" 200 OK
INFO:     127.0.0.1:49775 - "GET /api/analytics/top-customers?limit=5 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49778 - "GET /api/analytics/top-products?limit=6 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49781 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:49786 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:49788 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:49790 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:49797 - "OPTIONS /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:49799 - "OPTIONS /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:49797 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:49799 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:49800 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:49802 - "GET /api/emails/inbox?filter_status=new&limit=50&offset=0 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49804 - "GET /api/tone-settings HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:49806 - "GET /api/templates HTTP/1.1" 307 Temporary Redirect
INFO:     127.0.0.1:49799 - "GET /api/tone-settings/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:49797 - "GET /api/templates/ HTTP/1.1" 200 OK
INFO:     127.0.0.1:49809 - "GET /api/emails/inbox?filter_status=new&limit=50&offset=0 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49823 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
INFO:     127.0.0.1:49825 - "GET /api/emails/settings/settings HTTP/1.1" 200 OK
WARNING:  WatchFiles detected changes in 'app/routers/google_auth.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [49851]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [51703]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/main.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [51703]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [51710]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/gmail_api_connector.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [51710]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [51729]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Will watch for changes in these directories: ['/Users/alexbelski/Desktop/new bi project/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [51919] using WatchFiles
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [51926]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/config.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [51926]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
WARNING:  WatchFiles detected changes in 'app/routers/google_auth.py'. Reloading...
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [65371]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/routers/google_auth.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [65371]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [65377]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/routers/email_settings.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [65377]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [65383]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     127.0.0.1:53364 - "GET /api/google/auth-url HTTP/1.1" 400 Bad Request
INFO:     127.0.0.1:56453 - "GET /api/google/auth-url HTTP/1.1" 400 Bad Request
WARNING:  WatchFiles detected changes in 'app/config.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [65383]
Process SpawnProcess-6:
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 320, in _bootstrap
    self.run()
    ~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/_subprocess.py", line 78, in subprocess_started
    target(sockets=sockets)
    ~~~~~~^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 62, in run
    return asyncio.run(self.serve(sockets=sockets))
           ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 204, in run
    return runner.run(main)
           ~~~~~~~~~~^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 127, in run
    return self._loop.run_until_complete(task)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "uvloop/loop.pyx", line 1518, in uvloop.loop.Loop.run_until_complete
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 69, in serve
    config.load()
    ~~~~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/config.py", line 458, in load
    self.loaded_app = import_from_string(self.app)
                      ~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/importer.py", line 21, in import_from_string
    module = importlib.import_module(module_str)
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/importlib/__init__.py", line 88, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1398, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1371, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1342, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 938, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 759, in exec_module
  File "<frozen importlib._bootstrap>", line 491, in _call_with_frames_removed
  File "/Users/alexbelski/Desktop/new bi project/backend/app/main.py", line 3, in <module>
    from app.routers import analytics, upload, email, proposals, forecast, salary
  File "/Users/alexbelski/Desktop/new bi project/backend/app/routers/analytics.py", line 4, in <module>
    from app.database import supabase
  File "/Users/alexbelski/Desktop/new bi project/backend/app/database.py", line 3, in <module>
    from app.config import settings
  File "/Users/alexbelski/Desktop/new bi project/backend/app/config.py", line 36, in <module>
    settings = get_settings()
  File "/Users/alexbelski/Desktop/new bi project/backend/app/config.py", line 33, in get_settings
    return Settings()
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/pydantic_settings/main.py", line 71, in __init__
    super().__init__(
    ~~~~~~~~~~~~~~~~^
        **__pydantic_self__._settings_build_values(
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<7 lines>...
        )
        ^
    )
    ^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/pydantic/main.py", line 250, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
pydantic_core._pydantic_core.ValidationError: 1 validation error for Settings
supabase_key
  Extra inputs are not permitted [type=extra_forbidden, input_value='eyJhbGciOiJIUzI1NiIsInR5...F_XLy_JfwaU8wHdiOloKrlo', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
WARNING:  WatchFiles detected changes in 'app/database.py'. Reloading...
Process SpawnProcess-7:
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 320, in _bootstrap
    self.run()
    ~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/_subprocess.py", line 78, in subprocess_started
    target(sockets=sockets)
    ~~~~~~^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 62, in run
    return asyncio.run(self.serve(sockets=sockets))
           ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 204, in run
    return runner.run(main)
           ~~~~~~~~~~^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 127, in run
    return self._loop.run_until_complete(task)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "uvloop/loop.pyx", line 1518, in uvloop.loop.Loop.run_until_complete
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 69, in serve
    config.load()
    ~~~~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/config.py", line 458, in load
    self.loaded_app = import_from_string(self.app)
                      ~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/importer.py", line 21, in import_from_string
    module = importlib.import_module(module_str)
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/importlib/__init__.py", line 88, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1398, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1371, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1342, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 938, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 759, in exec_module
  File "<frozen importlib._bootstrap>", line 491, in _call_with_frames_removed
  File "/Users/alexbelski/Desktop/new bi project/backend/app/main.py", line 3, in <module>
    from app.routers import analytics, upload, email, proposals, forecast, salary
  File "/Users/alexbelski/Desktop/new bi project/backend/app/routers/analytics.py", line 4, in <module>
    from app.database import supabase
  File "/Users/alexbelski/Desktop/new bi project/backend/app/database.py", line 3, in <module>
    from app.config import settings
  File "/Users/alexbelski/Desktop/new bi project/backend/app/config.py", line 36, in <module>
    settings = get_settings()
  File "/Users/alexbelski/Desktop/new bi project/backend/app/config.py", line 33, in get_settings
    return Settings()
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/pydantic_settings/main.py", line 71, in __init__
    super().__init__(
    ~~~~~~~~~~~~~~~~^
        **__pydantic_self__._settings_build_values(
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<7 lines>...
        )
        ^
    )
    ^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/pydantic/main.py", line 250, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
pydantic_core._pydantic_core.ValidationError: 1 validation error for Settings
supabase_key
  Extra inputs are not permitted [type=extra_forbidden, input_value='eyJhbGciOiJIUzI1NiIsInR5...F_XLy_JfwaU8wHdiOloKrlo', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
WARNING:  WatchFiles detected changes in 'app/config.py'. Reloading...
Process SpawnProcess-8:
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 320, in _bootstrap
    self.run()
    ~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/_subprocess.py", line 78, in subprocess_started
    target(sockets=sockets)
    ~~~~~~^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 62, in run
    return asyncio.run(self.serve(sockets=sockets))
           ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 204, in run
    return runner.run(main)
           ~~~~~~~~~~^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 127, in run
    return self._loop.run_until_complete(task)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "uvloop/loop.pyx", line 1518, in uvloop.loop.Loop.run_until_complete
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 69, in serve
    config.load()
    ~~~~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/config.py", line 458, in load
    self.loaded_app = import_from_string(self.app)
                      ~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/importer.py", line 21, in import_from_string
    module = importlib.import_module(module_str)
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/importlib/__init__.py", line 88, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1398, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1371, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1342, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 938, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 759, in exec_module
  File "<frozen importlib._bootstrap>", line 491, in _call_with_frames_removed
  File "/Users/alexbelski/Desktop/new bi project/backend/app/main.py", line 3, in <module>
    from app.routers import analytics, upload, email, proposals, forecast, salary
  File "/Users/alexbelski/Desktop/new bi project/backend/app/routers/analytics.py", line 4, in <module>
    from app.database import supabase
  File "/Users/alexbelski/Desktop/new bi project/backend/app/database.py", line 9, in <module>
    if settings.supabase_url and settings.supabase_service_key:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/pydantic/main.py", line 1026, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
AttributeError: 'Settings' object has no attribute 'supabase_service_key'
WARNING:  WatchFiles detected changes in 'app/database.py'. Reloading...
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [74908]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/routers/inbox.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [74908]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
Process SpawnProcess-10:
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 320, in _bootstrap
    self.run()
    ~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/_subprocess.py", line 78, in subprocess_started
    target(sockets=sockets)
    ~~~~~~^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 62, in run
    return asyncio.run(self.serve(sockets=sockets))
           ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 204, in run
    return runner.run(main)
           ~~~~~~~~~~^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 127, in run
    return self._loop.run_until_complete(task)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "uvloop/loop.pyx", line 1518, in uvloop.loop.Loop.run_until_complete
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 69, in serve
    config.load()
    ~~~~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/config.py", line 458, in load
    self.loaded_app = import_from_string(self.app)
                      ~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/importer.py", line 21, in import_from_string
    module = importlib.import_module(module_str)
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/importlib/__init__.py", line 88, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1398, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1371, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1342, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 938, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 759, in exec_module
  File "<frozen importlib._bootstrap>", line 491, in _call_with_frames_removed
  File "/Users/alexbelski/Desktop/new bi project/backend/app/main.py", line 4, in <module>
    from app.routers import email_settings, inbox, tone_settings, templates, google_auth
  File "/Users/alexbelski/Desktop/new bi project/backend/app/routers/inbox.py", line 24
    new_record = {
IndentationError: unexpected indent
WARNING:  WatchFiles detected changes in 'app/main.py'. Reloading...
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
Process SpawnProcess-11:
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 320, in _bootstrap
    self.run()
    ~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/_subprocess.py", line 78, in subprocess_started
    target(sockets=sockets)
    ~~~~~~^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 62, in run
    return asyncio.run(self.serve(sockets=sockets))
           ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 204, in run
    return runner.run(main)
           ~~~~~~~~~~^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 127, in run
    return self._loop.run_until_complete(task)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "uvloop/loop.pyx", line 1518, in uvloop.loop.Loop.run_until_complete
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 69, in serve
    config.load()
    ~~~~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/config.py", line 458, in load
    self.loaded_app = import_from_string(self.app)
                      ~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/importer.py", line 21, in import_from_string
    module = importlib.import_module(module_str)
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/importlib/__init__.py", line 88, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1398, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1371, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1342, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 938, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 759, in exec_module
  File "<frozen importlib._bootstrap>", line 491, in _call_with_frames_removed
  File "/Users/alexbelski/Desktop/new bi project/backend/app/main.py", line 4, in <module>
    from app.routers import email_settings, inbox, tone_settings, templates, google_auth
  File "/Users/alexbelski/Desktop/new bi project/backend/app/routers/inbox.py", line 24
    new_record = {
IndentationError: unexpected indent
WARNING:  WatchFiles detected changes in 'app/routers/inbox.py'. Reloading...
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [76409]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/ai_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [76409]
/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/openai/_compat.py:48: UserWarning: Core Pydantic V1 functionality isn't compatible with Python 3.14 or greater.
  from pydantic.v1.typing import (
INFO:     Started server process [76808]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [76808]
INFO:     Stopping reloader process [51919]
INFO:     Will watch for changes in these directories: ['/Users/alexbelski/Desktop/new bi project/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [23053] using WatchFiles
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
Failed to initialize Groq client: __init__() got an unexpected keyword argument 'proxies'
Process SpawnProcess-1:
Traceback (most recent call last):
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/multiprocessing/process.py", line 315, in _bootstrap
    self.run()
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/_subprocess.py", line 78, in subprocess_started
    target(sockets=sockets)
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/server.py", line 62, in run
    return asyncio.run(self.serve(sockets=sockets))
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/runners.py", line 44, in run
    return loop.run_until_complete(main)
  File "uvloop/loop.pyx", line 1518, in uvloop.loop.Loop.run_until_complete
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/server.py", line 69, in serve
    config.load()
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/config.py", line 458, in load
    self.loaded_app = import_from_string(self.app)
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/importer.py", line 24, in import_from_string
    raise exc from None
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/importer.py", line 21, in import_from_string
    module = importlib.import_module(module_str)
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py", line 127, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File "<frozen importlib._bootstrap>", line 1030, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1007, in _find_and_load
  File "<frozen importlib._bootstrap>", line 986, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 680, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 850, in exec_module
  File "<frozen importlib._bootstrap>", line 228, in _call_with_frames_removed
  File "/Users/alexbelski/Desktop/new bi project/backend/app/main.py", line 115, in <module>
    from app.routers import intelligent_chat
  File "/Users/alexbelski/Desktop/new bi project/backend/app/routers/intelligent_chat.py", line 9, in <module>
    from app.services.unified_intelligence_service import unified_intelligence_service
  File "/Users/alexbelski/Desktop/new bi project/backend/app/services/unified_intelligence_service.py", line 17, in <module>
    from app.services.sql_query_service import sql_query_service
  File "/Users/alexbelski/Desktop/new bi project/backend/app/services/sql_query_service.py", line 10, in <module>
    from groq import Groq
ModuleNotFoundError: No module named 'groq'
Supabase admin client initialized (RLS bypass enabled)
INFO:     Will watch for changes in these directories: ['/Users/alexbelski/Desktop/new bi project/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [23779] using WatchFiles
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [23787]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
Supabase admin client initialized (RLS bypass enabled)
INFO:     127.0.0.1:56401 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56403 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56401 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56403 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56424 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56426 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56424 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56428 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56426 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56430 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:56424 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56428 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56433 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56430 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:56426 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56434 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:56433 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:56424 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56428 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
RPC not available for top-products: {'code': '42702', 'details': 'It could refer to either a PL/pgSQL variable or a table column.', 'hint': None, 'message': 'column reference "total_revenue" is ambiguous'}
INFO:     127.0.0.1:56434 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
Importing plotly failed. Interactive plots will not work.
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56430 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56426 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56433 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:56424 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:56428 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56434 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56430 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56426 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56424 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:56433 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56430 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56430 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56467 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56468 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56544 - "OPTIONS /api/ai-chat/chat HTTP/1.1" 200 OK
ERROR:app.services.secure_query_service:Database error: could not translate host name "db.hnunemnxpmyhexzcvmtb.supabase.co" to address: nodename nor servname provided, or not known

WARNING:app.services.unified_intelligence_service:[QUALITY] -3 for no data on INTERNAL_DB query
INFO:     127.0.0.1:56544 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
ERROR:app.services.secure_query_service:Database error: could not translate host name "db.hnunemnxpmyhexzcvmtb.supabase.co" to address: nodename nor servname provided, or not known

WARNING:app.services.unified_intelligence_service:[QUALITY] -3 for no data on INTERNAL_DB query
INFO:     127.0.0.1:56580 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
ERROR:app.services.secure_query_service:Database error: could not translate host name "db.hnunemnxpmyhexzcvmtb.supabase.co" to address: nodename nor servname provided, or not known

WARNING:app.services.unified_intelligence_service:[QUALITY] -3 for no data on INTERNAL_DB query
INFO:     127.0.0.1:56658 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
INFO:     127.0.0.1:56691 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:56692 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56691 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:56692 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56698 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56698 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56692 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56692 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56698 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56698 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56692 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56692 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56881 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'code': '42702', 'details': 'It could refer to either a PL/pgSQL variable or a table column.', 'hint': None, 'message': 'column reference "total_revenue" is ambiguous'}
INFO:     127.0.0.1:56883 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56881 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56884 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56883 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56887 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:56884 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56889 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56887 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:56890 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56889 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56890 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56889 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56889 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56920 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56923 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56924 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:56926 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56928 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56930 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:56928 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56953 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:56955 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56953 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:56955 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56958 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56958 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56955 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56958 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56955 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56958 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56955 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56955 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56955 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56958 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56955 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:56958 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57019 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:57019 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57023 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:57025 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57019 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57025 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:57023 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57019 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:57023 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57025 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57019 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57025 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57023 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57019 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57023 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57025 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57019 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57025 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57019 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57025 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57019 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57022 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57019 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57018 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57017 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57163 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:57165 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57165 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57165 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57165 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57165 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57196 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57198 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57199 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57196 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:57203 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:57198 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57199 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57196 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57203 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57199 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57198 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57196 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57202 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:57203 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:57199 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57198 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:57196 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57203 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57203 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:57203 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57196 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57205 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:57202 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
WARNING:  WatchFiles detected changes in 'app/services/sql_query_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [23787]
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [31630]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
Supabase admin client initialized (RLS bypass enabled)
INFO:     127.0.0.1:62785 - "GET /health HTTP/1.1" 200 OK
INFO:     127.0.0.1:62927 - "OPTIONS /api/ai-chat/chat HTTP/1.1" 200 OK
Database error: could not translate host name "db.hnunemnxpmyhexzcvmtb.supabase.co" to address: nodename nor servname provided, or not known

[QUALITY] -3 for no data on INTERNAL_DB query
INFO:     127.0.0.1:62927 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
Database error: could not translate host name "db.hnunemnxpmyhexzcvmtb.supabase.co" to address: nodename nor servname provided, or not known

[QUALITY] -3 for no data on INTERNAL_DB query
INFO:     127.0.0.1:62982 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
Error in get_sales_summary: {'code': 'PGRST200', 'details': "Searched for a foreign key relationship between 'sale_items' and 'sales' in the schema 'public', but no matches were found.", 'hint': "Perhaps you meant 'sales_plans' instead of 'sale_items'.", 'message': "Could not find a relationship between 'sale_items' and 'sales' in the schema cache"}
INFO:     127.0.0.1:63047 - "GET /api/data/analytics/summary HTTP/1.1" 200 OK
INFO:     127.0.0.1:63086 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63088 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63086 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63089 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63088 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63092 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:63086 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63089 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63093 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63092 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:63088 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63095 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:63093 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:63086 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63089 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
RPC not available for top-products: {'code': '42702', 'details': 'It could refer to either a PL/pgSQL variable or a table column.', 'hint': None, 'message': 'column reference "total_revenue" is ambiguous'}
INFO:     127.0.0.1:63092 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
Importing plotly failed. Interactive plots will not work.
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:63088 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63095 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63093 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:63086 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:63089 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63095 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:63088 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63092 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:63086 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:63093 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:63088 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:63088 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63113 - "OPTIONS /api/analytics/refresh HTTP/1.1" 200 OK
INFO:     127.0.0.1:63113 - "POST /api/analytics/refresh HTTP/1.1" 200 OK
INFO:     127.0.0.1:63113 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
INFO:     127.0.0.1:63113 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63113 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:63849 - "OPTIONS /api/ai-chat/chat HTTP/1.1" 200 OK
WARNING:app.services.secure_query_service:Query blocked: Query must start with one of: SELECT, EXPLAIN. Query: WITH current_year AS (SELECT SUM(total_amount) as total, EXTRACT(MONTH FROM sale_date) as month FROM sales WHERE EXTRACT(YEAR FROM sale_date) = EXTRACT(YEAR FROM CURRENT_DATE) GROUP BY EXTRACT(MONTH F
WARNING:app.services.sql_query_service:Security violation blocked: Security Violation: Query must start with one of: SELECT, EXPLAIN
WARNING:app.services.unified_intelligence_service:[QUALITY] -3 for no data on INTERNAL_DB query
INFO:     127.0.0.1:63849 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
INFO:     127.0.0.1:63926 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:63927 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63926 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:63927 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63934 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63934 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63927 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63927 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63934 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63934 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63927 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63927 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
WARNING:  WatchFiles detected changes in 'app/services/unified_intelligence_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [31630]
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [39500]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/unified_intelligence_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [39500]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [42813]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/unified_intelligence_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [42813]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [42896]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
Supabase admin client initialized (RLS bypass enabled)
INFO:     127.0.0.1:51259 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51261 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51263 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51259 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51261 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51264 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51264 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51259 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
WARNING:  WatchFiles detected changes in 'app/services/ai_context_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [42896]
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [59881]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/ai_context_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [59881]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [59939]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/routers/data_validation.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [59939]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [59956]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/main.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [59956]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [59976]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/cache_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [59976]
Supabase admin client initialized (RLS bypass enabled)
Process SpawnProcess-10:
Traceback (most recent call last):
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/multiprocessing/process.py", line 315, in _bootstrap
    self.run()
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/_subprocess.py", line 78, in subprocess_started
    target(sockets=sockets)
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/server.py", line 62, in run
    return asyncio.run(self.serve(sockets=sockets))
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/asyncio/runners.py", line 44, in run
    return loop.run_until_complete(main)
  File "uvloop/loop.pyx", line 1518, in uvloop.loop.Loop.run_until_complete
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/server.py", line 69, in serve
    config.load()
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/config.py", line 458, in load
    self.loaded_app = import_from_string(self.app)
  File "/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/uvicorn/importer.py", line 21, in import_from_string
    module = importlib.import_module(module_str)
  File "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py", line 127, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File "<frozen importlib._bootstrap>", line 1030, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1007, in _find_and_load
  File "<frozen importlib._bootstrap>", line 986, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 680, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 850, in exec_module
  File "<frozen importlib._bootstrap>", line 228, in _call_with_frames_removed
  File "/Users/alexbelski/Desktop/new bi project/backend/app/main.py", line 11, in <module>
    from app.routers import analytics, upload, proposals, forecast, salary
  File "/Users/alexbelski/Desktop/new bi project/backend/app/routers/analytics.py", line 6, in <module>
    from app.services.cache_service import cache
  File "/Users/alexbelski/Desktop/new bi project/backend/app/services/cache_service.py", line 13, in <module>
    class CacheService:
  File "/Users/alexbelski/Desktop/new bi project/backend/app/services/cache_service.py", line 108, in CacheService
    def get_agent_cache_keys(self, agent_id: Optional[str] = None) -> List[str]:
NameError: name 'List' is not defined
Supabase admin client initialized (RLS bypass enabled)
WARNING:  WatchFiles detected changes in 'app/services/cache_service.py'. Reloading...
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [60416]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
Supabase admin client initialized (RLS bypass enabled)
INFO:     127.0.0.1:53820 - "GET /api/data-validation/status HTTP/1.1" 200 OK
WARNING:  WatchFiles detected changes in 'app/routers/files_router.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [60416]
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [60489]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/routers/files_router.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [60489]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [60494]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/routers/agent_analytics.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [60494]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [60495]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/routers/cache_debug.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [60495]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [60510]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/main.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [60510]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [60521]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/main.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [60521]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [61534]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/unified_intelligence_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [61534]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [62091]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/routers/files_router.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [62091]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [63207]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/google_sheets_importer.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [63207]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [67743]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'fix_agent_data.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [67743]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [70110]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'create_sample_data.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [70110]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [76298]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'fix_agent_ids.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [76298]
Supabase admin client initialized (RLS bypass enabled)
WARNING:  WatchFiles detected changes in 'fix_agent_ids.py'. Reloading...
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [79494]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/ai_context_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [79494]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [81496]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/ai_context_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [81496]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [86817]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/ai_context_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [86817]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [86839]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/ai_context_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [86839]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [86888]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
WARNING:  WatchFiles detected changes in 'app/services/ai_context_service.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [86888]
Supabase admin client initialized (RLS bypass enabled)
/Users/alexbelski/Desktop/new bi project/.venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
INFO:     Started server process [86953]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [86953]
Supabase admin client initialized (RLS bypass enabled)
INFO:     Stopping reloader process [23779]
INFO:     Will watch for changes in these directories: ['/Users/alexbelski/Desktop/new bi project/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [11926] using WatchFiles
Process SpawnProcess-1:
Traceback (most recent call last):
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 320, in _bootstrap
    self.run()
    ~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/_subprocess.py", line 78, in subprocess_started
    target(sockets=sockets)
    ~~~~~~^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 62, in run
    return asyncio.run(self.serve(sockets=sockets))
           ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 204, in run
    return runner.run(main)
           ~~~~~~~~~~^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py", line 127, in run
    return self._loop.run_until_complete(task)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "uvloop/loop.pyx", line 1518, in uvloop.loop.Loop.run_until_complete
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/server.py", line 69, in serve
    config.load()
    ~~~~~~~~~~~^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/config.py", line 458, in load
    self.loaded_app = import_from_string(self.app)
                      ~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/importer.py", line 24, in import_from_string
    raise exc from None
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/site-packages/uvicorn/importer.py", line 21, in import_from_string
    module = importlib.import_module(module_str)
  File "/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/importlib/__init__.py", line 88, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1398, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1371, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1342, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 938, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 759, in exec_module
  File "<frozen importlib._bootstrap>", line 491, in _call_with_frames_removed
  File "/Users/alexbelski/Desktop/new bi project/backend/app/main.py", line 115, in <module>
    from app.routers import intelligent_chat
  File "/Users/alexbelski/Desktop/new bi project/backend/app/routers/intelligent_chat.py", line 9, in <module>
    from app.services.unified_intelligence_service import unified_intelligence_service
  File "/Users/alexbelski/Desktop/new bi project/backend/app/services/unified_intelligence_service.py", line 17, in <module>
    from app.services.sql_query_service import sql_query_service
  File "/Users/alexbelski/Desktop/new bi project/backend/app/services/sql_query_service.py", line 8, in <module>
    import sqlparse
ModuleNotFoundError: No module named 'sqlparse'
Supabase admin client initialized (RLS bypass enabled)
INFO:     Will watch for changes in these directories: ['/Users/alexbelski/Desktop/new bi project/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [11994] using WatchFiles
INFO:     Started server process [11996]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
Supabase admin client initialized (RLS bypass enabled)
INFO:     127.0.0.1:58853 - "GET /health HTTP/1.1" 200 OK
INFO:     127.0.0.1:58933 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:58934 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:58933 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:58934 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59021 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59022 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59044 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59046 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59048 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59044 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59050 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59046 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:59048 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59052 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
Importing plotly failed. Interactive plots will not work.
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59050 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59044 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59054 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:59052 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59054 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59050 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59082 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:59084 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59084 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59084 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59084 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59084 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59187 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59188 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59187 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59188 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59444 - "OPTIONS /api/salary/calculate?year=2026&month=1 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59446 - "OPTIONS /api/salary/calculate?year=2026&month=1 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59444 - "GET /api/salary/calculate?year=2026&month=1 HTTP/1.1" 404 Not Found
INFO:     127.0.0.1:59444 - "GET /api/salary/calculate?year=2026&month=1 HTTP/1.1" 404 Not Found
INFO:     127.0.0.1:59444 - "GET /api/salary/export?year=2026&month=1 HTTP/1.1" 500 Internal Server Error
INFO:     127.0.0.1:59469 - "GET /api/files/list HTTP/1.1" 200 OK
INFO:     127.0.0.1:59469 - "GET /api/files/list HTTP/1.1" 200 OK
INFO:     127.0.0.1:59469 - "GET /api/files/list HTTP/1.1" 200 OK
INFO:     127.0.0.1:59469 - "GET /api/files/list HTTP/1.1" 200 OK
INFO:     127.0.0.1:59469 - "GET /api/files/list HTTP/1.1" 200 OK
INFO:     127.0.0.1:59469 - "GET /api/files/list HTTP/1.1" 200 OK
INFO:     127.0.0.1:59495 - "GET /api/files/list HTTP/1.1" 200 OK
INFO:     127.0.0.1:59495 - "GET /api/files/list HTTP/1.1" 200 OK
INFO:     127.0.0.1:59584 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59586 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59584 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59588 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59586 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59590 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59588 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59584 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59592 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59586 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59590 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59594 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:59588 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:59584 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59592 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:59594 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59586 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59590 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59588 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59584 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:59592 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59590 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59586 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59594 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59584 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59588 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59594 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59594 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59607 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:59609 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59607 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:59609 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59612 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59612 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59616 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59616 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59612 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59612 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59616 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59616 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59656 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59658 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59656 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59660 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59658 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59662 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59660 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59664 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59662 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59658 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59666 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:59664 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59660 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59680 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59666 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59658 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59662 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:59664 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59658 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59666 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59664 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59658 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59691 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59693 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59691 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59695 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59693 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59697 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59695 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59700 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59697 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59701 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59700 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59701 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59700 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59700 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59700 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59701 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59700 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59701 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59733 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59736 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59733 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59739 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59736 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59739 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59743 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59744 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59743 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59744 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59743 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59744 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59743 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59739 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59736 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59744 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59741 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:59750 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59739 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:59736 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59743 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59750 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59744 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59743 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59739 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59736 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59750 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59744 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59744 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59750 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59744 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59750 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59750 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59741 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59750 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59778 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59780 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59800 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59802 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59800 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59804 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59802 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59806 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59804 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59809 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59806 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59810 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59809 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59810 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59809 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59809 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59810 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59806 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59810 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59806 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59886 - "GET /api/salary/calculate?year=2026&month=1 HTTP/1.1" 404 Not Found
INFO:     127.0.0.1:59886 - "GET /api/salary/calculate?year=2026&month=1 HTTP/1.1" 404 Not Found
INFO:     127.0.0.1:59919 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59921 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59919 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59921 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59934 - "OPTIONS /api/agent-analytics/agents/e2611800-7cde-409c-a19a-f95f4893c82f HTTP/1.1" 200 OK
INFO:     127.0.0.1:59936 - "OPTIONS /api/agent-analytics/agents/e2611800-7cde-409c-a19a-f95f4893c82f HTTP/1.1" 200 OK
INFO:     127.0.0.1:59934 - "GET /api/agent-analytics/agents/e2611800-7cde-409c-a19a-f95f4893c82f HTTP/1.1" 200 OK
INFO:     127.0.0.1:59934 - "GET /api/agent-analytics/agents/e2611800-7cde-409c-a19a-f95f4893c82f HTTP/1.1" 200 OK
INFO:     127.0.0.1:59934 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59948 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59934 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:59950 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59948 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59952 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59950 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:59934 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59955 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59952 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59956 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:59955 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59952 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59955 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:59956 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:59952 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59955 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:59956 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59934 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59956 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59955 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59956 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59955 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59956 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59955 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:59955 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60004 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60034 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60036 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60034 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60036 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60054 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:60056 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60054 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60057 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60056 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60060 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:60054 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60062 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60060 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60063 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60062 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60063 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60062 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60060 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:60054 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60060 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60062 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60054 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60074 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60074 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60054 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60054 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60074 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60074 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60083 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60083 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60083 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60074 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60083 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60095 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60074 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60099 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:60083 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60100 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60099 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60101 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60100 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60101 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60100 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60100 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60125 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60126 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60125 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60126 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60270 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60271 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60270 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60273 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60271 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60276 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:60273 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60271 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60279 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60271 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60806 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60809 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60806 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60810 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60809 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60812 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60806 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60809 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60827 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60829 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60827 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60831 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:60829 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60833 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60831 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60827 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:60835 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:60833 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:60829 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60831 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:60835 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60827 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60833 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60829 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60831 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60835 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:60829 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60833 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60827 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60833 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60829 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60829 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60829 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60825 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60895 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60895 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60895 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60895 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60895 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60908 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60911 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60908 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60912 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60911 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:60914 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:60912 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60917 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60914 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60918 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60917 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:60918 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60917 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:60917 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60945 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60946 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60945 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60946 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60946 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:60945 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60946 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:60945 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60954 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60958 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60954 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60945 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60959 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60958 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60959 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60958 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60954 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60954 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60958 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60954 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61278 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:61279 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61278 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61281 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61279 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61283 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61278 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61281 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61286 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61283 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61279 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61287 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61286 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61278 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61281 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61287 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61283 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61279 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61281 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61286 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61278 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61287 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61283 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61279 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61286 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61278 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61281 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61287 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61283 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61279 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61278 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61286 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61281 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61283 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61287 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61279 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61278 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61281 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61286 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61283 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61286 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61278 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61281 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61283 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61323 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61281 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61286 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61325 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61283 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61323 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61325 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61278 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61377 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61379 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61377 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61379 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61388 - "OPTIONS /api/agent-analytics/agents/e2611800-7cde-409c-a19a-f95f4893c82f HTTP/1.1" 200 OK
INFO:     127.0.0.1:61390 - "OPTIONS /api/agent-analytics/agents/e2611800-7cde-409c-a19a-f95f4893c82f HTTP/1.1" 200 OK
INFO:     127.0.0.1:61388 - "GET /api/agent-analytics/agents/e2611800-7cde-409c-a19a-f95f4893c82f HTTP/1.1" 200 OK
INFO:     127.0.0.1:61388 - "GET /api/agent-analytics/agents/e2611800-7cde-409c-a19a-f95f4893c82f HTTP/1.1" 200 OK
INFO:     127.0.0.1:61496 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61500 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61496 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61502 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61500 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61504 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61502 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61506 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61504 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61507 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61506 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61507 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61506 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61506 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61506 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61507 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61507 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61506 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61536 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31&region=%D0%92%D0%98%D0%A2%D0%95%D0%91%D0%A1%D0%9A HTTP/1.1" 200 OK
INFO:     127.0.0.1:61538 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31&region=%D0%92%D0%98%D0%A2%D0%95%D0%91%D0%A1%D0%9A HTTP/1.1" 200 OK
INFO:     127.0.0.1:61536 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31&region=%D0%92%D0%98%D0%A2%D0%95%D0%91%D0%A1%D0%9A HTTP/1.1" 200 OK
INFO:     127.0.0.1:61538 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31&region=%D0%92%D0%98%D0%A2%D0%95%D0%91%D0%A1%D0%9A HTTP/1.1" 200 OK
INFO:     127.0.0.1:61591 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61593 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61591 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61593 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61601 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61601 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61593 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61593 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61601 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61601 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61593 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61601 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61626 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61626 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61626 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61626 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61626 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61748 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61750 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61752 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61748 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61750 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61754 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61752 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61756 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61748 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61750 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:61754 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61756 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61752 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61748 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61750 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61754 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61756 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61752 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61754 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61748 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61750 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61752 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61756 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:61754 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:61750 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61748 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61752 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61754 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61756 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61748 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:61750 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61752 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61754 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61756 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61754 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61756 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61752 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61756 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61757 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62509 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:62510 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62509 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:62510 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62517 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62517 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62525 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62525 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62517 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62517 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62525 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62525 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62658 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62659 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62658 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62659 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63210 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:63212 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63210 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:63212 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63220 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63220 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63212 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63212 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63220 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63220 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63212 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63238 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63539 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63540 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63539 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63540 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:63542 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63552 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63542 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:63540 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63552 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63540 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63552 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63540 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63552 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63540 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63552 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63552 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64205 - "OPTIONS /api/ai-chat/chat HTTP/1.1" 200 OK
ERROR:app.services.unified_intelligence_service:Intent classification failed: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
ERROR:app.services.unified_intelligence_service:AI synthesis error: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
INFO:     127.0.0.1:64205 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
INFO:     127.0.0.1:64655 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64657 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64655 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64660 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64657 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64661 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64655 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64657 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64713 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:64713 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:64719 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:64713 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:64719 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:64711 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:64713 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:64709 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:64719 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:64718 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:64711 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:64719 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:64718 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64713 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:64719 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64713 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:64719 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:64713 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:64716 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:64719 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64713 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:64711 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64719 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64709 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
ERROR:app.services.unified_intelligence_service:Intent classification failed: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
ERROR:app.services.unified_intelligence_service:AI synthesis error: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
INFO:     127.0.0.1:64718 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:64711 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64713 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64719 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:64711 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64716 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64719 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:64711 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64771 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64718 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64771 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64771 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64711 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64807 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64809 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64807 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64809 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64809 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-31&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64807 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-31&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64809 - "GET /api/agent-analytics/dashboard?period_start=2025-12-31&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64807 - "GET /api/agent-analytics/agents?period_start=2025-12-31&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64807 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64809 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64807 - "GET /api/agent-analytics/agents?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64809 - "GET /api/agent-analytics/dashboard?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64807 - "GET /api/agent-analytics/dashboard?period_start=2025-12-31&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64828 - "GET /api/agent-analytics/agents?period_start=2025-12-31&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64828 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-30&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64828 - "GET /api/agent-analytics/dashboard?period_start=2025-12-30&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64839 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-30&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64842 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64839 - "GET /api/agent-analytics/agents?period_start=2025-12-30&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64843 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64842 - "GET /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64843 - "GET /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64842 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-07 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64839 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-07 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64842 - "GET /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-07 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64839 - "GET /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-07 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64843 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64828 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64828 - "GET /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64843 - "GET /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64843 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-23 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64843 - "GET /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-23 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64863 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-23 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64863 - "GET /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-23 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64843 - "GET /api/agent-analytics/dashboard?period_start=2025-12-16&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64865 - "GET /api/agent-analytics/agents?period_start=2025-12-16&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64877 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-01&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64879 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-01&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64877 - "GET /api/agent-analytics/dashboard?period_start=2025-12-01&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64879 - "GET /api/agent-analytics/agents?period_start=2025-12-01&period_end=2026-01-20 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64879 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-01&period_end=2025-12-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64877 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-01&period_end=2025-12-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64877 - "GET /api/agent-analytics/dashboard?period_start=2025-12-01&period_end=2025-12-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64879 - "GET /api/agent-analytics/agents?period_start=2025-12-01&period_end=2025-12-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64895 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-01&period_end=2026-01-24 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64896 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-01&period_end=2026-01-24 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64895 - "GET /api/agent-analytics/dashboard?period_start=2025-12-01&period_end=2026-01-24 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64896 - "GET /api/agent-analytics/agents?period_start=2025-12-01&period_end=2026-01-24 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64895 - "OPTIONS /api/agent-analytics/dashboard?period_start=2025-12-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64899 - "OPTIONS /api/agent-analytics/agents?period_start=2025-12-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64895 - "GET /api/agent-analytics/dashboard?period_start=2025-12-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64899 - "GET /api/agent-analytics/agents?period_start=2025-12-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64934 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:64935 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64957 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:64958 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64958 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64958 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:64958 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
ERROR:app.services.unified_intelligence_service:Intent classification failed: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
ERROR:app.services.unified_intelligence_service:AI synthesis error: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
INFO:     127.0.0.1:64997 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
INFO:     127.0.0.1:65180 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:65182 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65180 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:65182 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65186 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65186 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65182 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65182 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65186 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65186 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65218 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:65220 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65222 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:65220 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65224 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65218 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:65256 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:65257 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65260 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65257 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65260 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65257 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65260 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65257 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65260 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65369 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65370 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65369 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65373 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65370 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65374 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:65373 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:65377 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65374 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:65378 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:65377 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65373 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:65370 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:65378 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:65373 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:65377 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65370 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65374 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:65377 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65370 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65373 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65373 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65370 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65370 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65426 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65426 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65429 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65431 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65429 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:65433 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:65431 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:65434 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:65433 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:65436 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:65434 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:65436 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:65434 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:65434 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49155 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:49155 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:49157 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49157 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49155 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49155 - "GET /api/analytics/plan-fact?period_start=2025-12-31&period_end=2026-01-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49157 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49157 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49155 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49155 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:49698 - "OPTIONS /api/ai-chat/chat HTTP/1.1" 200 OK
ERROR:app.services.unified_intelligence_service:Intent classification failed: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
ERROR:app.services.unified_intelligence_service:AI synthesis error: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
INFO:     127.0.0.1:49698 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
INFO:     127.0.0.1:50314 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:50315 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50315 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50315 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50315 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50690 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50692 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50690 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50694 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50692 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50697 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:50694 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50690 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50699 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50697 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:50692 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50700 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:50694 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:50690 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50699 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:50697 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50692 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:50700 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50694 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:50690 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:50699 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50697 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:50692 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50700 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:50694 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:50690 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50699 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:50697 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:50700 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:50692 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50699 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:50690 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50699 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:50690 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50692 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50692 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50690 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50690 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
ERROR:app.services.unified_intelligence_service:Intent classification failed: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
ERROR:app.services.unified_intelligence_service:AI synthesis error: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
INFO:     127.0.0.1:50981 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
INFO:     127.0.0.1:50981 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:50997 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50981 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:50997 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51001 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51001 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50997 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:50997 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51001 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51001 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51081 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:51083 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51083 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51083 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51083 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51159 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:51161 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51161 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51161 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51161 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51243 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:51245 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51245 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51245 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51245 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51516 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:51517 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51517 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51517 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51517 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51700 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:51702 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51702 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51702 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51702 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51903 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:51904 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51904 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51904 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51904 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51904 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:51932 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51932 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51932 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:51932 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52070 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:52072 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52072 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52072 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52072 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52470 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:52472 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52472 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52472 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52472 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52909 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:52911 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52911 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52911 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:52911 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53140 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53142 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53140 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53142 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53146 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53140 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53142 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53142 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53140 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53146 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:53163 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53140 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53146 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53142 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53164 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53163 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:53164 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:53140 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53142 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:53146 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53163 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:53164 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:53146 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:53140 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:53142 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53163 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:53146 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:53164 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:53163 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:53146 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:53163 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53164 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:53146 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53163 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53163 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53144 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53788 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:53790 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53790 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53790 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:53790 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54222 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:54224 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54222 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54226 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54224 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54228 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:54226 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54231 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54228 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:54232 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54231 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:54232 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54231 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54232 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54231 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54248 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54232 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:54248 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54231 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54248 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54231 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54231 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54248 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54248 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54297 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:54298 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54298 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54298 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54298 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54730 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54730 - "OPTIONS /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54734 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "OPTIONS /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "OPTIONS /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54734 - "OPTIONS /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:54730 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54738 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "OPTIONS /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "OPTIONS /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54734 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54730 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54738 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:54737 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54738 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54730 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54734 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:54728 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54730 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54734 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:54738 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54734 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54730 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54738 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54734 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:54730 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54738 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54734 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54730 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54738 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:54734 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54737 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54737 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54737 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54728 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54732 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54737 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54840 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54842 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54840 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54845 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54842 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:54846 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:54845 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54849 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54846 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:54850 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54849 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:54850 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54849 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:54849 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54998 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:55000 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:54998 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:55000 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55006 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55006 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55000 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55000 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55006 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55006 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55428 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
WARNING:app.routers.analytics:RPC not available for top-products: {'message': 'column reference "total_revenue" is ambiguous', 'code': '42702', 'hint': None, 'details': 'It could refer to either a PL/pgSQL variable or a table column.'}
INFO:     127.0.0.1:55430 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55428 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55432 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55430 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55434 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:55432 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:55436 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55434 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:55430 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55428 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:55438 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:55436 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55432 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55432 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55436 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:55438 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:55434 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:55432 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55430 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:55428 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:55438 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55436 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55430 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:55428 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55432 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:55438 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55428 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55430 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55428 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55430 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55430 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55889 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55890 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55889 - "GET /api/analytics/sales-trend?period=month&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55892 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55890 - "GET /api/analytics/top-products?limit=6&force_refresh=false HTTP/1.1" 200 OK
INFO:     127.0.0.1:55894 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
INFO:     127.0.0.1:55892 - "GET /api/analytics/top-customers?limit=5&force_refresh=false HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:55896 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55894 - "GET /api/analytics/dashboard HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:55898 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:55896 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55892 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55890 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:277: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:278: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:282: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ym'] = df['ds'].dt.to_period('M')
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:284: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  monthly_totals['month'] = monthly_totals['ym'].dt.month
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:304: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  daily_totals['weekday'] = daily_totals['ds'].dt.dayofweek
INFO:     127.0.0.1:55898 - "GET /api/forecast/seasonality HTTP/1.1" 200 OK
INFO:     127.0.0.1:55892 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:55890 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:55896 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:88: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['ds'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:89: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['y'] = df['total_amount'].astype(float)
ERROR:root:Error training Prophet model: 'Prophet' object has no attribute 'stan_backend'
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:199: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['sale_date'] = pd.to_datetime(df['sale_date'])
/Users/alexbelski/Desktop/new bi project/backend/app/services/forecast_service.py:200: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df['month'] = df['sale_date'].dt.to_period('M')
INFO:     127.0.0.1:55896 - "GET /api/forecast/predict?months_ahead=3 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60776 - "OPTIONS /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60777 - "OPTIONS /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60776 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60777 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:60777 - "OPTIONS /api/ai-chat/chat HTTP/1.1" 200 OK
ERROR:app.services.unified_intelligence_service:Intent classification failed: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
ERROR:app.services.unified_intelligence_service:AI synthesis error: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
INFO:     127.0.0.1:60776 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
ERROR:app.services.unified_intelligence_service:Intent classification failed: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
ERROR:app.services.unified_intelligence_service:AI synthesis error: Error code: 403 - {'error': {'message': 'Access denied. Please check your network settings.'}}
INFO:     127.0.0.1:60877 - "POST /api/ai-chat/chat HTTP/1.1" 200 OK
INFO:     127.0.0.1:61058 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61060 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61058 - "GET /api/agent-analytics/dashboard?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61064 - "GET /api/agent-analytics/agents?period_start=2026-01-01&period_end=2026-01-31 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61076 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61077 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61076 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61077 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61080 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61080 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61077 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61077 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61080 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61077 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61188 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61190 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61190 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61190 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61190 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61458 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61459 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61459 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61459 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61459 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61504 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61506 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61506 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61506 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61506 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61613 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61614 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61614 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61614 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61614 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61711 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61713 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61713 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61713 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61713 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61713 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61732 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61732 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61732 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61732 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61790 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:61792 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61792 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61792 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:61792 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62285 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:62286 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62286 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62286 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:62286 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63065 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:63067 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63067 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63067 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63067 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63151 - "GET /api/analytics/filter-options HTTP/1.1" 200 OK
INFO:     127.0.0.1:63152 - "GET /api/analytics/abc-xyz?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63152 - "GET /api/analytics/geo?days=90 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63152 - "GET /api/analytics/lfl?period1_start=2025-12-31&period1_end=2026-01-30&period2_start=2025-11-30&period2_end=2025-12-30 HTTP/1.1" 200 OK
INFO:     127.0.0.1:63152 - "GET /api/analytics/boston-matrix?days=90 HTTP/1.1" 200 OK
WARNING:  WatchFiles detected changes in 'tests/conftest.py', 'tests/test_unified_importer_batching.py', 'app/services/excel_parser.py', 'app/routers/salary.py', 'tests/test_excel_parser_optimization.py', 'tests/test_unified_importer_customers_mock.py', 'app/services/forecast_service.py', 'app/services/unified_importer.py', 'app/services/google_sheets_importer.py'. Reloading...
INFO:     Shutting down
INFO:     Waiting for application shutdown.
INFO:     Application shutdown complete.
INFO:     Finished server process [11996]
INFO:     Started server process [28200]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
